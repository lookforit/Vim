set nocompatible
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin
nunmap <c-a>
colorscheme candycode
set guifont=consolas:h13

"编码方式设置：
set encoding=utf-8
set fileencoding=chinese
language message zh_CN.utf-8
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim

set diffexpr=MyDiff()
function MyDiff()
	let opt = '-a --binary '
	if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
	if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
	let arg1 = v:fname_in
	if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
	let arg2 = v:fname_new
	if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
	let arg3 = v:fname_out
	if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
	let eq = ''
	if $VIMRUNTIME =~ ' '
		if &sh =~ '\<cmd'
			let cmd = '""' . $VIMRUNTIME . '\diff"'
			let eq = '"'
		else
			let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
		endif
	else
		let cmd = $VIMRUNTIME . '\diff'
	endif
	silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
endfunction
source $VIMRUNTIME/macros/matchit.vim
autocmd BufEnter *.m    compiler mlint
:set showmatch

if has("autocmd") && exists("+omnifunc") 
	autocmd Filetype * 
				\	if &omnifunc == "" | 
				\	 setlocal omnifunc=syntaxcomplete#Complete | 
				\	endif 
endif



source $VIMRUNTIME/macros/MakeMatlabComment.vim 
map <M-c> :call MakeMatlabComment()<CR> 
imap <M-c> <ESC>:call MakeMatlabComment()<CR>

au GUIEnter * simalt ~x	"Maxmize the startup window
set nowritebackup
set nobackup
set ignorecase smartcase
set report=0
set noswapfile

if has("gui_running")
	set guioptions-=m " 隐藏菜单栏
	set guioptions-=T " 隐藏工具栏
	set guioptions-=L " 隐藏左侧滚动条
	set guioptions-=r " 隐藏右侧滚动条
	set guioptions-=b " 隐藏底部滚动条
	" set showtabline=0 " 隐藏Tab栏
endif

"keys map:


" 插入模式下上下左右移动光标
inoremap <s-h> <left>
inoremap <s-l> <right>
inoremap <s-j> <c-o>gj
inoremap <s-k> <c-o>gk

" 窗口间移动:
map <M-Right> <c-w>l
map <M-Left> <c-w>h
map <M-Up> <c-w>k
map <M-Down> <c-w>j
imap <M-Right> <ESC><c-w>l
imap <M-Left> <ESC><c-w>h
imap <M-Up> <ESC><c-w>k
imap <M-Down> <ESC><c-w>j

"normal模式下换行：
map <c-CR>  :put=''<CR>

"关闭一个buffer：
map <m-q>   :q<CR>

"设置当前编辑文件的路径为当前路径:
map <F2> :lcd %:h<CR>

"复制到剪贴板:
vmap <F3> "+y

"删除或复制到括号中的内容，Shift包含括号本身：
let g:yankring_zap_keys = 'f'

"快捷关掉其它窗口
noremap <Leader>q :only<CR>

"通过"%%" 快捷输入当前buffer目录(windows版本，linux下需将"\"替换为"/")
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'\' : '%%'

"打开和关闭搜索高亮:
map <a-m> :set nohlsearch<CR>
map <a-n> :set hlsearch<CR>

"为自动完成习惯：
imap <c-j> <c-x><c-o>
inoremap <expr> <c-k> pumvisible()?"\<Up>":"\<c-k>"  
inoremap <expr> <c-j> pumvisible()?"\<Down>":"\<c-j>"  

"acp 习惯:
"let g:acp_completeOption ='.,t,i'	"让AutoComplPop插件在弹出时，在更多的地方查找。
"let g:acp_enableAtStartup = 0

"Voom 设定:
map <F12> :Voom<CR>
:set fmr=<<<,>>>

"打开括号匹配彩色显示(rainbow 插件)
au syntax * cal rainbow#activate()

"TagHighlight设置：
if ! exists('g:TagHighlightSettings')
	let g:TagHighlightSettings = {}
endif
let g:TagHighlightSettings['IncludeLocals'] =1 		

"Pathogen :
call pathogen#infect() 

"TagList 设置:
"let Tlist_Show_One_File=1		" 不同时显示多个文件的 tag ，只显示当前文件的
""let Tlist_File_Fold_Auto_Close=1	"让当前不被编辑的文件的方法列表自动折叠起来 
"let Tlist_Use_Right_Window=1 		"把taglist窗口放在屏幕的右侧，缺省在左侧 
"let Tlist_Show_Menu=1			"显示taglist菜单
"nmap <silent> <F11> :Tlist<cr>		

"Tagbar设置:
nmap <silent> <F11> :TagbarToggle<cr>		
let g:tagbar_width = 30


"NeoCompleteCache :
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
"select first:
let g:neocomplcache_enable_auto_select=0
"Enable fuzzy match:
let g:neocomplcache_enable_fuzzy_completion=1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Use camel case completion.
let g:neocomplcache_enable_camel_case_completion = 1
" Use underbar completion.
let g:neocomplcache_enable_underbar_completion = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
			\ 'default' : '',
			\ 'vimshell' : $HOME.'/.vimshell_hist',
			\ 'scheme' : $HOME.'/.gosh_completions'
			\ }

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
	let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <expr><CR>  neocomplcache#close_popup() . "\<CR>"
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()

"Enter select items:
inoremap <expr><space>  pumvisible() ? neocomplcache#close_popup()  : "\<SPACE>"
"Caching everywhere:
noremap <Leader>neo :NeoComplCacheCachingBuffer<CR>:NeoComplCacheCachingTags<CR>
" For cursor moving in insert mode(Not recommended)


"inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
"inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
"inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
"inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
" Or set this.
"let g:neocomplcache_enable_cursor_hold_i = 1
" Or set this.
"let g:neocomplcache_enable_insert_char_pre = 1

" AutoComplPop like behavior.
"let g:neocomplcache_enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
"let g:neocomplcache_enable_auto_select = 1
"let g:neocomplcache_disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"
"inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
	let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
"autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'





"winmanager 设置：
let g:winManagerWindowLayout='NERDTree|TagList'		"设置界面分割
""let g:winManagerWindowLayout = "TagList|FileExplorer"
let g:winManagerWidth = 30 				"设置winmanager的宽度，默认为25

"定义打开关闭winmanager按键
nmap <silent> <C-F11> :WMToggle<cr>		


"NERDTree 设置：
let g:NERDTree_title='NERD Tree'
function! NERDTree_Start()
	exec 'NERDTree'
endfunction

"一直显示书签
let NERDTreeShowBookmarks=1 

"NERDTree 快捷键绑定
map <F10> :NERDTree<CR>
map <s-F10> :NERDTreeClose<CR>

function! NERDTree_IsValid()
	return 1
endfunction

"NERDTree中不显示的文件后缀名或目录名称：
let NERDTreeIgnore=['\.uvopt$', '\~$','\.uvproj','\.dll','\makefile','\.svn','\.bak','\.dep','\.plg','\.taghl','\.out']

"窗口全屏:
map <a-F12> <Esc>:call libcallnr("gvimfullscreen.dll", "ToggleFullScreen", 0)<CR>

"Cscope
"查找声明
nmap <C-Space>s :cs find s <C-R>=expand("<cword>")<CR><CR>
"查找定义
nmap <C-Space>g :cs find g <C-R>=expand("<cword>")<CR><CR>
"查找调用
nmap <C-Space>c :cs find c <C-R>=expand("<cword>")<CR><CR>
"查找指定的字符串
nmap <C-Space>t :cs find t <C-R>=expand("<cword>")<CR><CR>
"查找egrep模式，相当于egrep功能，但查找速度快多了
nmap <C-Space>e :cs find e <C-R>=expand("<cword>")<CR><CR>
"查找文件
nmap <C-Space>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
"查找包含本文件的文件
nmap <C-Space>i :cs find i <C-R>=expand("<cfile>")<CR><CR>
"查找本函数调用的函数
nmap <C-Space>d :cs find d <C-R>=expand("<cword>")<CR><CR>


"CtrlP (new fuzzy finder)扩展设置：
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript']
let g:ctrlp_map = ',e'
nmap ,g :CtrlPBufTag<CR>
nmap ,f :CtrlPLine<CR>
nmap ,m :CtrlPMRUFiles<CR>
" to be able to call CtrlP with default search text
function! CtrlPWithSearchText(search_text, ctrlp_command_end)
	execute ':CtrlP' . a:ctrlp_command_end
	call feedkeys(a:search_text)
endfunction
" CtrlP with default text
nmap ,wg :call CtrlPWithSearchText(expand('<cword>'), 'BufTag')<CR>
nmap ,wf :call CtrlPWithSearchText(expand('<cword>'), 'Line')<CR>
nmap ,d ,wg
nmap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<CR>
nmap ,pe :call CtrlPWithSearchText(expand('<cfile>'), '')<CR>
" Don't change working directory
let g:ctrlp_working_path_mode = 0



"对 txt 文本文件的特殊处理(让其易用VIMIM输入法):
autocmd FileType txt :NeoComplCacheDisable	
autocmd FileType txt set completeopt=longest
let g:vimim_cloud='sogou'


"对 easybuffer 插件进行快捷键:
nmap ,b :EasyBufferHorizontal<CR>

"对 a 插件进行快捷键(在.h和.c之间切换):
noremap <Leader>a :A<CR>  
noremap <Leader>ta :AT<CR>  

"高亮python: 
let python_highlight_all = 1

"pydiction 设置:
let g:pydiction_location = 'D:\Programe files\Vim\vimfiles\bundle\pydiction-1.2\ftplugin\pydiction\complete-dict' 
"Python Mode 设置: 
noremap <Leader>pp :PyLint<CR>  
noremap <Leader>pc :PyLintAuto<CR>
let g:pymode_lint_write=0 		"写入时不检查
"转到定义快捷键
autocmd FileType python nmap <buffer> <C-]> :RopeGotoDefinition<CR> 
"显示帮助信息
autocmd FileType python nmap <buffer> <Leader>d :RopeShowDoc<CR> 
let pymode_rope_vim_completion=1
let pymode_rope_extended_complete=1

"python在终端运行快捷键
autocmd FileType python nmap <buffer> <F5> :w<CR>:!python.exe %<CR> 

"vdebug(调试python)插件快捷键
let g:vdebug_keymap = {
    \    "run" : "<S-F5>",
    \    "run_to_cursor" : "<S-F1>",
    \    "step_over" : "<S-F2>",
    \    "step_into" : "<S-F3>",
    \    "step_out" : "<S-F4>",
    \    "close" : "<S-F6>",
    \    "detach" : "<S-F7>",
    \    "set_breakpoint" : "<S-F9>",
    \    "get_context" : "<S-F11>",
    \    "eval_under_cursor" : "<S-F12>",
    \}
let g:vdebug_options= {
    \    "port" : 9000,
    \    "server" : 'localhost',
    \    "timeout" : 20,
    \    "on_close" : 'detach',
    \    "break_on_open" : 0,
    \    "ide_key" : '',
    \    "remote_path" : "",
    \    "local_path" : "",
    \    "debug_window_level" : 0,
    \    "debug_file_level" : 0,
    \    "debug_file" : "",
    \}
let g:vdebug_options = {
\  "marker_default" : '*',
\  "marker_closed_tree" : '+',
\  "marker_open_tree" : '-'
\}

